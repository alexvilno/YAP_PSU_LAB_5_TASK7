# Лабораторная работа 5, вариант 7, ПГНИУ ЯП МФТИ-1 2022

Решение всех задач оформить в виде одного класса со статическими методами, решающими поставленные задачи. В классе могут присутствовать методы со спецификатором доступа private вспомогательного характера.

## Задание 1. Решить задачу, используя класс List
Составить программу, которая переносит в конец непустого списка L его
первый элемент.
Создаем новый список и добавляем туда 10 случайных чисел.

```c#
List<int> list = new List<int>();
Random rnd = new Random();
Console.WriteLine("Дан список: ");
for (int i = 0; i < 10; ++i)
{
    list.Add(rnd.Next(1, 100));
}
foreach (int i in list)
{
    Console.Write(i + " ");
}

Console.WriteLine();
Console.WriteLine("Ответ: ");
(list[0], list[^1]) = (list[^1], list[0]); //swap
```

И меняем первый и последний элементы местами.

Вывод:
```
ЗАДАЧА 1
Дан список: 
60 5 27 33 17 50 23 76 74 3 
Ответ: 
3 5 27 33 17 50 23 76 74 60 
----------------------------------------
```

## Задание 2. Решить задачу, используя класс LinkedList

из списка L, содержащего не менее двух элементов, удаляет все элементы, у
которых одинаковые «соседи» (первый и последний элементы считать
соседями);

Создаем LinkedList и заполняем его случайными числами

```c#
LinkedList<int> list = new LinkedList<int>();
Random rnd = new Random();
Console.WriteLine("Дан список: ");
for (int i = 0; i < 10; ++i)
{
    list.AddFirst(rnd.Next(1, 10));
}
```

Создаем указатель на первый узел в списке и двигаем его на следующий элемент (это нужно для того, чтобы проверить prev)

```c#
var current = list.First;
current = current.Next;
```

Далее идем по списку пока не достигнем конца и проверяем условие задачи

```c#
while (current != null && current != list.Last && list.Count >= 3)
{
    var old_cur = current;
    if (current.Previous.Value == current.Next.Value)
    {
        old_cur = current;
        list.Remove(current); //удаляем элемент с одинаковыми соседями

    }
    current = old_cur.Next;
}
```

Следующие две проверки позволяют обработать ситуацию, если соседи элемента находятся на разных концах списка:

```c#
if (list.Last.Previous.Value == list.First.Value)
{
    list.Remove(list.Last);
}

if (list.Last.Value == list.First.Next.Value)
{
    list.Remove(list.First);
}
```

Вывод:
```
ЗАДАЧА 2
Дан список: 
6 2 6 1 4 1 1 9 9 7 
Ответ: 
6 6 1 4 1 1 9 9 7 
----------------------------------------
```

## Задание3. Решить задачу, используя класс HashSet

Есть перечень мебельных фабрик, продукция которых представлена в мебельном магазине. Известно, мебель каких фабрик приобреталась n покупателями. Определить для каждой фабрики, мебель каких из них приобреталась всеми покупателями, каких — некоторыми из покупателей, и каких — никем из покупателей.

Идея состоит в том, чтобы использовать ```HashSet``` для хранения названий фабрик, и создать для каждого покупателя свой ```HashSet``` где будут храниться названия фабрик, мебель которых есть у покупателя. Для получения ответа нужно будет использовать пересечения, разность HashSet ов. 

```c#
HashSet<string>[] buyers = new HashSet<string>[k]; //k - покупателей

for (int i = 0; i < k; ++i)
{
    buyers[i] = new HashSet<string>(); //создаем хешсеты для каждого...
}
```

Ответ на первый вопрос получается пересечением пересечений хешсетов покупателей и хешсета фабрик

```c#
for (int i = 0; i < k; ++i) //в хешсет кадого покупателя записываем пересечение его хешсета и хешсета фабрик
{
    buyers[i].IntersectWith(fabriques);
}

for (int i = 1; i < k; ++i) //в хешсет 
{
    buyers[0].IntersectWith(buyers[i]);
}



if (buyers[0].Count != 0)
{
    Console.Write("Мебель этих фабрик есть у всех покупателей: ");
    foreach (var i in buyers[0])
    {
        Console.WriteLine(i + " ");
    }
}
else Console.WriteLine("Мебель ни одной фабрики не присутствует у всех покупателей.");
```

Ответ на второй вопрос получается объединением пересечений хешсетов покупателей и хешсета фабрик
```c#
for (int i = 0; i < k; ++i)
{
    buyers_copy[i].IntersectWith(fabriques);
}

for (int i = 0; i < k; ++i)
{
    buyers_copy[0].UnionWith(buyers_copy[i]);
}
```

Если ```buyers_copy[0]``` не пуст, ответом на третий вопрос будет расность хешсета фабрик и хешсета ```buyers_copy[0]```. 

```c#
if (buyers_copy[0].Count != 0)
{
    Console.Write("Мебель этих фабрик присутствует хотя бы у одного из покупателей: ");
    foreach (var i in buyers_copy[0])
    {
        Console.Write(i + " ");
    }

    fabriques.ExceptWith(buyers_copy[0]);

    Console.WriteLine();

    if (fabriques.Count != 0)
    {
        Console.Write("У этих фабрик нет ни одного покупателя: ");
        foreach(var i in fabriques)
        {
            Console.Write(i + " ");
        }
    }
    else Console.WriteLine("У всех фабрик есть хотя бы один покупатель.");
}
else Console.WriteLine("Ни у одной из фабрик нет ни одного покупателя.");
```

Например для входных данных
```
4
4
LAZURIT
IKEA
DOMADOM
UZBEK
IKEA
DOMADOM LAZURIT
ABOBAFURNITURE LAZURIT
LAZURIT IKEA DOMADOM UZBEK
```
Ответ будет таким:
```
Мебель ни одной фабрики не присутствует у всех покупателей.
Мебель этих фабрик присутствует хотя бы у одного из покупателей: DOMADOM LAZURIT IKEA UZBEK 
У всех фабрик есть хотя бы один покупатель.
----------------------------------------
```

А для таких: 

```
4
4
LAZURIT
IKEA
DOMADOM
UZBEK
IKEA LAZURIT
DOMADOM LAZURIT
ABOBAFURNITURE LAZURIT
LAZURIT IKEA DOMADOM
```

Ответ будет таким:
```
Мебель этих фабрик есть у всех покупателей: LAZURIT 
Мебель этих фабрик присутствует хотя бы у одного из покупателей: DOMADOM LAZURIT IKEA 
У этих фабрик нет ни одного покупателя: UZBEK 
----------------------------------------
```

## Задание 5. Решить задачу с использованием структуры «текстовый файл»


## Задание 4. Решить задачу, используя класс HashSet
Файл содержит текст на русском языке. Напечатать в алфавитном порядке все глухие согласные буквы, которые входят в каждое нечетное слово и не входят хотя бы одно четное слово.

Создадим хешсет всех глухих согласных букв(чтобы с ним потом пересечься)

```c#
HashSet<char> letters = new HashSet<char>();
HashSet<char> exists = new HashSet<char>();
string cons = "БВГДЖЗЛМНРЦЧбвгджзлмнрцч";

foreach (char i in cons)
{
    letters.Add(i);
}
```

Считывая строки из файла будем слитить их по пробелу. Создадим также ```List``` результатов пересечения хешсета каждой конкретной строки с нашим хешсетом букв ```letters```

```c#
string s = fin.ReadLine();
string[] split = s.Split(' ');
List<char> res = new List<char>();
```

Потом будем обрабатывать слова только нечетные по счету

```C#
for (int i = 0; i < split.Length; ++i)
{
    if (i % 2 == 0)
    {
        continue;
    }

    HashSet<char> temp = new HashSet<char>();

    foreach (char c in split[i])
    {
        temp.Add(c);
    }

    temp.IntersectWith(letters);//пересечение

    foreach (char c in temp)
    {
        res.Add(c);
    }
}
```

Потом нужно будет отсортировать res и добавить в ```exists``` его элементы

```c#
res.Sort();
foreach (char c in res)
{
    exists.Add(c);
}

Console.Write("Ответ: ");

foreach (char c in exists)
{
    Console.Write(c + " ");
}
```

Для такой строки 
```
Кризис грянул и нет спасенья,
Нет спасенья, хоть прыгай с кручи…
Все твои щас и к месту рвенья, глянь какие подходят тучи.
Глянь, какая сверкнула сабля, сколько сразу голов срубила,
А за саблей, упала капля, кровь барыги с асфальта смыла.
```

Вывод будет таким:
```
ЗАДАЧА 4
Дана строка: 
Кризис грянул и нет спасенья, нет спасенья, хоть прыгай с кручи… Все твои щас и к месту рвенья, глянь какие подходят тучи. Глянь, какая сверкнула сабля, сколько сразу голов срубила, А за саблей, упала капля, кровь барыги с асфальта смыла.
Ответ: В б в г з л м н р ч 
----------------------------------------
```

А для такой строки
```
а чцрнЦмлзжЧдгвб
```
Ответ такой
```
Дана строка: 
а чцрнЦмлзжЧдгвб
Ответ: Ц Ч б в г д ж з л м н р ц ч 
----------------------------------------
```

## Задание 6. Решить задачу с использованием структуры «текстовый файл»
Переписать в другой файл строки, содержащие заданную комбинацию символов. Например, строка «Сегодня старшеклассники выполняли ЕГЭ по информатике и ИКТ» содержит комбинацию «форма».

Решение заключается в поиске подстроки в каждой строке из массива с последующей записью строк с найденным шаблоном в файл вывода:
```c#
while ((value = fin.ReadLine()) != null)
{
    Console.WriteLine(value);
    if (value.Contains(template))
    {
        fout.WriteLine(value);
        ans.Add(value);
    }
}
```
Вывод:

```
ЗАДАНИЕ 6
Данные из файла:
ABOBABOBA
BOBABOBA
BOBOBO
AAAAA
ABOBOBA
Строки, содержащие шаблон ABOBA:
ABOBABOBA
BOBABOBA\
--------------------------------------------------------------------------------
```

